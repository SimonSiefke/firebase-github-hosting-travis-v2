const critical = require("critical");
const fs = require("fs");

let cssFiles;
let oldCssFiles;
let newCssFiles;
/**
 * this function updates the old css files for the serviceworker with the new ones generated by critical
 */

function replaceOldCssFiles() {
  // remove old
  for (const oldCssFile of oldCssFiles) {
    fs.unlinkSync(`dist/css/${oldCssFile}`);
  }

  // and replace with new
  newCssFiles.forEach((file, index) => {
    fs.renameSync(`dist/css/${file}`, `dist/css/${oldCssFiles[index]}`);
  });
}

function updateHtmlLinks() {
  const htmlFile = fs.readFileSync("dist/index.html", "utf-8");

  let updatedHtmlFile = htmlFile;
  newCssFiles.forEach((fileName, index) => {
    updatedHtmlFile = updatedHtmlFile.replace(
      new RegExp(fileName, "g"),
      oldCssFiles[index]
    );
  });

  fs.writeFileSync("dist/index.html", updatedHtmlFile);
}

function criticalWebpackPlugin(options) {
  this.options = options;
}

criticalWebpackPlugin.prototype.emit = function(compilation, callback) {
  critical.generate(this.options, (err, output) => {
    cssFiles = fs.readdirSync("dist/css");
    // old css files are named app.[hash].css
    oldCssFiles = cssFiles.filter(cssFile => cssFile.split(".").length === 3);
    // new css files are named app.[hash].[hash].css
    newCssFiles = cssFiles.filter(cssFile => cssFile.split(".").length === 4);
    replaceOldCssFiles();
    updateHtmlLinks();
    callback(err);
  });
};

criticalWebpackPlugin.prototype.apply = function(compiler) {
  var self = this;
  compiler.plugin("after-emit", function(compilation, callback) {
    self.emit(compilation, callback);
  });
};

module.exports = criticalWebpackPlugin;
